import _extends from '@babel/runtime/helpers/esm/extends';
import * as THREE from 'three';
import * as React from 'react';
import { extend, useThree, useFrame } from '@react-three/fiber';
import { useFBO } from './useFBO.js';

class MeshTransmissionMaterialImpl extends THREE.MeshPhysicalMaterial {
  constructor({
    samples = 10,
    ...args
  } = {}) {
    super(args);
    this.uniforms = {
      refraction: {
        value: 0
      },
      rgbShift: {
        value: 0.3
      },
      noise: {
        value: 0.03
      },
      saturation: {
        value: 1.0
      },
      contrast: {
        value: 1.0
      },
      buffer: {
        value: null
      },
      resolution: {
        value: new THREE.Vector2()
      }
    };

    this.onBeforeCompile = shader => {
      shader.uniforms = { ...shader.uniforms,
        ...this.uniforms
      };
      shader.fragmentShader = `uniform float rgbShift;
      uniform vec2 resolution;
      uniform float refraction;
      uniform float noise;
      uniform float saturation;
      uniform float contrast;
      uniform sampler2D buffer;
      
      float random(vec2 p) {
        return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }
    
      vec3 sat(vec3 rgb, float adjustment) {
        const vec3 W = vec3(0.2125, 0.7154, 0.0721);
        vec3 intensity = vec3(dot(rgb, W));
        return mix(intensity, rgb, adjustment);
      }
      ` + shader.fragmentShader;
      shader.fragmentShader = shader.fragmentShader.replace('#include <output_fragment>', `vec2 uv = gl_FragCoord.xy / resolution.xy;
        vec2 refractNormal = vNormal.xy * (1.0 - vNormal.xy * 0.85);
        vec3 refractCol = vec3(0.0);
        float slide;
        #pragma unroll_loop_start
        for (int i = 0; i < ${samples}; i ++) {
          slide = float(UNROLLED_LOOP_INDEX) / float(${samples}) * 0.1 + random(uv) * noise;              
          refractCol.r += texture2D(buffer, uv - refractNormal * (refraction + slide * 1.0) * rgbShift).r;
          refractCol.g += texture2D(buffer, uv - refractNormal * (refraction + slide * 2.0) * rgbShift).g;
          refractCol.b += texture2D(buffer, uv - refractNormal * (refraction + slide * 3.0) * rgbShift).b;
          refractCol = sat(refractCol, saturation);
        }
        #pragma unroll_loop_end
        outgoingLight *= refractCol / float(${samples}) * contrast;
        #include <output_fragment>`);
    };

    Object.keys(this.uniforms).forEach(name => Object.defineProperty(this, name, {
      get: () => this.uniforms[name].value,
      set: v => this.uniforms[name].value = v
    }));
  }

}

const MeshTransmissionMaterial = /*#__PURE__*/React.forwardRef(({
  buffer,
  samples = 10,
  resolution = 1024,
  background,
  ...props
}, fref) => {
  extend({
    MeshTransmissionMaterial: MeshTransmissionMaterialImpl
  });
  const ref = React.useRef(null);
  const {
    size,
    viewport
  } = useThree();
  const fbo = useFBO(resolution);
  const config = React.useMemo(() => ({
    samples
  }), [samples]);
  let oldBg;
  let oldVis;
  let parent;
  useFrame(state => {
    if (!buffer) {
      parent = ref.current.__r3f.parent;

      if (parent) {
        // Hide the outer groups contents
        oldVis = parent.visible;
        parent.visible = false; // Set render target to the local buffer

        state.gl.setRenderTarget(fbo); // Save the current background and set the HDR as the new BG
        // This is what creates the reflections

        oldBg = state.scene.background;
        if (background) state.scene.background = background; // Render into the buffer

        state.gl.render(state.scene, state.camera); // Set old state back

        state.scene.background = oldBg;
        state.gl.setRenderTarget(null);
        parent.visible = oldVis;
      }
    }
  }); // Forward ref

  React.useImperativeHandle(fref, () => ref.current, []);
  return /*#__PURE__*/React.createElement("meshTransmissionMaterial", _extends({
    args: [config],
    ref: ref,
    buffer: buffer || fbo.texture,
    resolution: [size.width * viewport.dpr, size.height * viewport.dpr]
  }, props));
});

export { MeshTransmissionMaterial };
