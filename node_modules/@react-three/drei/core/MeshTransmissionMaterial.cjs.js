"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),r=require("three"),t=require("react"),n=require("@react-three/fiber"),a=require("./useFBO.cjs.js");function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function u(e){if(e&&e.__esModule)return e;var r=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:function(){return e[t]}})}})),r.default=e,Object.freeze(r)}var i=o(e),s=u(r),f=u(t);class l extends s.MeshPhysicalMaterial{constructor({samples:e=10,...r}={}){super(r),this.uniforms={refraction:{value:0},rgbShift:{value:.3},noise:{value:.03},saturation:{value:1},contrast:{value:1},buffer:{value:null},resolution:{value:new s.Vector2}},this.onBeforeCompile=r=>{r.uniforms={...r.uniforms,...this.uniforms},r.fragmentShader="uniform float rgbShift;\n      uniform vec2 resolution;\n      uniform float refraction;\n      uniform float noise;\n      uniform float saturation;\n      uniform float contrast;\n      uniform sampler2D buffer;\n      \n      float random(vec2 p) {\n        return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n      }\n    \n      vec3 sat(vec3 rgb, float adjustment) {\n        const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n        vec3 intensity = vec3(dot(rgb, W));\n        return mix(intensity, rgb, adjustment);\n      }\n      "+r.fragmentShader,r.fragmentShader=r.fragmentShader.replace("#include <output_fragment>",`vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec2 refractNormal = vNormal.xy * (1.0 - vNormal.xy * 0.85);\n        vec3 refractCol = vec3(0.0);\n        float slide;\n        #pragma unroll_loop_start\n        for (int i = 0; i < ${e}; i ++) {\n          slide = float(UNROLLED_LOOP_INDEX) / float(${e}) * 0.1 + random(uv) * noise;              \n          refractCol.r += texture2D(buffer, uv - refractNormal * (refraction + slide * 1.0) * rgbShift).r;\n          refractCol.g += texture2D(buffer, uv - refractNormal * (refraction + slide * 2.0) * rgbShift).g;\n          refractCol.b += texture2D(buffer, uv - refractNormal * (refraction + slide * 3.0) * rgbShift).b;\n          refractCol = sat(refractCol, saturation);\n        }\n        #pragma unroll_loop_end\n        outgoingLight *= refractCol / float(${e}) * contrast;\n        #include <output_fragment>`)},Object.keys(this.uniforms).forEach((e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:r=>this.uniforms[e].value=r})))}}const c=f.forwardRef((({buffer:e,samples:r=10,resolution:t=1024,background:o,...u},s)=>{n.extend({MeshTransmissionMaterial:l});const c=f.useRef(null),{size:m,viewport:d}=n.useThree(),v=a.useFBO(t),g=f.useMemo((()=>({samples:r})),[r]);let b,h,p;return n.useFrame((r=>{e||(p=c.current.__r3f.parent,p&&(h=p.visible,p.visible=!1,r.gl.setRenderTarget(v),b=r.scene.background,o&&(r.scene.background=o),r.gl.render(r.scene,r.camera),r.scene.background=b,r.gl.setRenderTarget(null),p.visible=h))})),f.useImperativeHandle(s,(()=>c.current),[]),f.createElement("meshTransmissionMaterial",i.default({args:[g],ref:c,buffer:e||v.texture,resolution:[m.width*d.dpr,m.height*d.dpr]},u))}));exports.MeshTransmissionMaterial=c;
